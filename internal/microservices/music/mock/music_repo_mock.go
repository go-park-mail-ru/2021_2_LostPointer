// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"2021_2_LostPointer/internal/microservices/music"
	"2021_2_LostPointer/internal/microservices/music/proto"
	"2021_2_LostPointer/internal/models"
	"sync"
)

// Ensure, that MockStorage does implement music.Storage.
// If this is not the case, regenerate this file with moq.
var _ music.Storage = &MockStorage{}

// MockStorage is a mock implementation of music.Storage.
//
// 	func TestSomethingThatUsesStorage(t *testing.T) {
//
// 		// make and configure a mocked music.Storage
// 		mockedStorage := &MockStorage{
// 			AddTrackToFavoritesFunc: func(n1 int64, n2 int64) error {
// 				panic("mock out the AddTrackToFavorites method")
// 			},
// 			AlbumDataFunc: func(n int64) (*proto.AlbumPageResponse, error) {
// 				panic("mock out the AlbumData method")
// 			},
// 			AlbumTracksFunc: func(n1 int64, n2 int64, b bool) ([]*proto.AlbumTrack, error) {
// 				panic("mock out the AlbumTracks method")
// 			},
// 			ArtistAlbumsFunc: func(n1 int64, n2 int64) ([]*proto.Album, error) {
// 				panic("mock out the ArtistAlbums method")
// 			},
// 			ArtistInfoFunc: func(n int64) (*proto.Artist, error) {
// 				panic("mock out the ArtistInfo method")
// 			},
// 			ArtistTracksFunc: func(n1 int64, n2 int64, b bool, n3 int64) ([]*proto.Track, error) {
// 				panic("mock out the ArtistTracks method")
// 			},
// 			DeleteTrackFromFavoritesFunc: func(n1 int64, n2 int64) error {
// 				panic("mock out the DeleteTrackFromFavorites method")
// 			},
// 			DoesPlaylistExistFunc: func(n int64) (bool, error) {
// 				panic("mock out the DoesPlaylistExist method")
// 			},
// 			FindAlbumsFunc: func(s string) ([]*proto.Album, error) {
// 				panic("mock out the FindAlbums method")
// 			},
// 			FindArtistsFunc: func(s string) ([]*proto.Artist, error) {
// 				panic("mock out the FindArtists method")
// 			},
// 			FindTracksByFullWordFunc: func(s string, n int64, b bool) ([]*proto.Track, error) {
// 				panic("mock out the FindTracksByFullWord method")
// 			},
// 			FindTracksByPartialFunc: func(s string, n int64, b bool) ([]*proto.Track, error) {
// 				panic("mock out the FindTracksByPartial method")
// 			},
// 			GetCompilationFunc: func(n int64) (*models.Selection, error) {
// 				panic("mock out the GetCompilation method")
// 			},
// 			GetFavoriteTracksIDFunc: func(n int64) ([]string, error) {
// 				panic("mock out the GetFavoriteTracksID method")
// 			},
// 			GetFavoritesFunc: func(n int64) ([]*proto.Track, error) {
// 				panic("mock out the GetFavorites method")
// 			},
// 			GetTracksByIDFunc: func(strings []string, n int64, b bool) ([]*proto.Track, error) {
// 				panic("mock out the GetTracksByID method")
// 			},
// 			GetTracksCompilationFunc: func(n int64, strings []string) ([]string, error) {
// 				panic("mock out the GetTracksCompilation method")
// 			},
// 			IncrementListenCountFunc: func(n int64) error {
// 				panic("mock out the IncrementListenCount method")
// 			},
// 			IsPlaylistOwnerFunc: func(n1 int64, n2 int64) (bool, error) {
// 				panic("mock out the IsPlaylistOwner method")
// 			},
// 			IsPlaylistPublicFunc: func(n int64) (bool, error) {
// 				panic("mock out the IsPlaylistPublic method")
// 			},
// 			IsTrackInFavoritesFunc: func(n1 int64, n2 int64) (bool, error) {
// 				panic("mock out the IsTrackInFavorites method")
// 			},
// 			PlaylistInfoFunc: func(n int64) (*proto.PlaylistData, error) {
// 				panic("mock out the PlaylistInfo method")
// 			},
// 			PlaylistTracksFunc: func(n1 int64, n2 int64) ([]*proto.Track, error) {
// 				panic("mock out the PlaylistTracks method")
// 			},
// 			RandomAlbumsFunc: func(n int64) (*proto.Albums, error) {
// 				panic("mock out the RandomAlbums method")
// 			},
// 			RandomArtistsFunc: func(n int64) (*proto.Artists, error) {
// 				panic("mock out the RandomArtists method")
// 			},
// 			RandomTracksFunc: func(n1 int64, n2 int64, b bool) ([]*proto.Track, error) {
// 				panic("mock out the RandomTracks method")
// 			},
// 			StoreCompilationFunc: func(n int64, selection *models.Selection) error {
// 				panic("mock out the StoreCompilation method")
// 			},
// 			UserPlaylistsFunc: func(n int64) ([]*proto.PlaylistData, error) {
// 				panic("mock out the UserPlaylists method")
// 			},
// 		}
//
// 		// use mockedStorage in code that requires music.Storage
// 		// and then make assertions.
//
// 	}
type MockStorage struct {
	// AddTrackToFavoritesFunc mocks the AddTrackToFavorites method.
	AddTrackToFavoritesFunc func(n1 int64, n2 int64) error

	// AlbumDataFunc mocks the AlbumData method.
	AlbumDataFunc func(n int64) (*proto.AlbumPageResponse, error)

	// AlbumTracksFunc mocks the AlbumTracks method.
	AlbumTracksFunc func(n1 int64, n2 int64, b bool) ([]*proto.AlbumTrack, error)

	// ArtistAlbumsFunc mocks the ArtistAlbums method.
	ArtistAlbumsFunc func(n1 int64, n2 int64) ([]*proto.Album, error)

	// ArtistInfoFunc mocks the ArtistInfo method.
	ArtistInfoFunc func(n int64) (*proto.Artist, error)

	// ArtistTracksFunc mocks the ArtistTracks method.
	ArtistTracksFunc func(n1 int64, n2 int64, b bool, n3 int64) ([]*proto.Track, error)

	// DeleteTrackFromFavoritesFunc mocks the DeleteTrackFromFavorites method.
	DeleteTrackFromFavoritesFunc func(n1 int64, n2 int64) error

	// DoesPlaylistExistFunc mocks the DoesPlaylistExist method.
	DoesPlaylistExistFunc func(n int64) (bool, error)

	// FindAlbumsFunc mocks the FindAlbums method.
	FindAlbumsFunc func(s string) ([]*proto.Album, error)

	// FindArtistsFunc mocks the FindArtists method.
	FindArtistsFunc func(s string) ([]*proto.Artist, error)

	// FindTracksByFullWordFunc mocks the FindTracksByFullWord method.
	FindTracksByFullWordFunc func(s string, n int64, b bool) ([]*proto.Track, error)

	// FindTracksByPartialFunc mocks the FindTracksByPartial method.
	FindTracksByPartialFunc func(s string, n int64, b bool) ([]*proto.Track, error)

	// GetCompilationFunc mocks the GetCompilation method.
	GetCompilationFunc func(n int64) (*models.Selection, error)

	// GetFavoriteTracksIDFunc mocks the GetFavoriteTracksID method.
	GetFavoriteTracksIDFunc func(n int64) ([]string, error)

	// GetFavoritesFunc mocks the GetFavorites method.
	GetFavoritesFunc func(n int64) ([]*proto.Track, error)

	// GetTracksByIDFunc mocks the GetTracksByID method.
	GetTracksByIDFunc func(strings []string, n int64, b bool) ([]*proto.Track, error)

	// GetTracksCompilationFunc mocks the GetTracksCompilation method.
	GetTracksCompilationFunc func(n int64, strings []string) ([]string, error)

	// IncrementListenCountFunc mocks the IncrementListenCount method.
	IncrementListenCountFunc func(n int64) error

	// IsPlaylistOwnerFunc mocks the IsPlaylistOwner method.
	IsPlaylistOwnerFunc func(n1 int64, n2 int64) (bool, error)

	// IsPlaylistPublicFunc mocks the IsPlaylistPublic method.
	IsPlaylistPublicFunc func(n int64) (bool, error)

	// IsTrackInFavoritesFunc mocks the IsTrackInFavorites method.
	IsTrackInFavoritesFunc func(n1 int64, n2 int64) (bool, error)

	// PlaylistInfoFunc mocks the PlaylistInfo method.
	PlaylistInfoFunc func(n int64) (*proto.PlaylistData, error)

	// PlaylistTracksFunc mocks the PlaylistTracks method.
	PlaylistTracksFunc func(n1 int64, n2 int64) ([]*proto.Track, error)

	// RandomAlbumsFunc mocks the RandomAlbums method.
	RandomAlbumsFunc func(n int64) (*proto.Albums, error)

	// RandomArtistsFunc mocks the RandomArtists method.
	RandomArtistsFunc func(n int64) (*proto.Artists, error)

	// RandomTracksFunc mocks the RandomTracks method.
	RandomTracksFunc func(n1 int64, n2 int64, b bool) ([]*proto.Track, error)

	// StoreCompilationFunc mocks the StoreCompilation method.
	StoreCompilationFunc func(n int64, selection *models.Selection) error

	// UserPlaylistsFunc mocks the UserPlaylists method.
	UserPlaylistsFunc func(n int64) ([]*proto.PlaylistData, error)

	// calls tracks calls to the methods.
	calls struct {
		// AddTrackToFavorites holds details about calls to the AddTrackToFavorites method.
		AddTrackToFavorites []struct {
			// N1 is the n1 argument value.
			N1 int64
			// N2 is the n2 argument value.
			N2 int64
		}
		// AlbumData holds details about calls to the AlbumData method.
		AlbumData []struct {
			// N is the n argument value.
			N int64
		}
		// AlbumTracks holds details about calls to the AlbumTracks method.
		AlbumTracks []struct {
			// N1 is the n1 argument value.
			N1 int64
			// N2 is the n2 argument value.
			N2 int64
			// B is the b argument value.
			B bool
		}
		// ArtistAlbums holds details about calls to the ArtistAlbums method.
		ArtistAlbums []struct {
			// N1 is the n1 argument value.
			N1 int64
			// N2 is the n2 argument value.
			N2 int64
		}
		// ArtistInfo holds details about calls to the ArtistInfo method.
		ArtistInfo []struct {
			// N is the n argument value.
			N int64
		}
		// ArtistTracks holds details about calls to the ArtistTracks method.
		ArtistTracks []struct {
			// N1 is the n1 argument value.
			N1 int64
			// N2 is the n2 argument value.
			N2 int64
			// B is the b argument value.
			B bool
			// N3 is the n3 argument value.
			N3 int64
		}
		// DeleteTrackFromFavorites holds details about calls to the DeleteTrackFromFavorites method.
		DeleteTrackFromFavorites []struct {
			// N1 is the n1 argument value.
			N1 int64
			// N2 is the n2 argument value.
			N2 int64
		}
		// DoesPlaylistExist holds details about calls to the DoesPlaylistExist method.
		DoesPlaylistExist []struct {
			// N is the n argument value.
			N int64
		}
		// FindAlbums holds details about calls to the FindAlbums method.
		FindAlbums []struct {
			// S is the s argument value.
			S string
		}
		// FindArtists holds details about calls to the FindArtists method.
		FindArtists []struct {
			// S is the s argument value.
			S string
		}
		// FindTracksByFullWord holds details about calls to the FindTracksByFullWord method.
		FindTracksByFullWord []struct {
			// S is the s argument value.
			S string
			// N is the n argument value.
			N int64
			// B is the b argument value.
			B bool
		}
		// FindTracksByPartial holds details about calls to the FindTracksByPartial method.
		FindTracksByPartial []struct {
			// S is the s argument value.
			S string
			// N is the n argument value.
			N int64
			// B is the b argument value.
			B bool
		}
		// GetCompilation holds details about calls to the GetCompilation method.
		GetCompilation []struct {
			// N is the n argument value.
			N int64
		}
		// GetFavoriteTracksID holds details about calls to the GetFavoriteTracksID method.
		GetFavoriteTracksID []struct {
			// N is the n argument value.
			N int64
		}
		// GetFavorites holds details about calls to the GetFavorites method.
		GetFavorites []struct {
			// N is the n argument value.
			N int64
		}
		// GetTracksByID holds details about calls to the GetTracksByID method.
		GetTracksByID []struct {
			// Strings is the strings argument value.
			Strings []string
			// N is the n argument value.
			N int64
			// B is the b argument value.
			B bool
		}
		// GetTracksCompilation holds details about calls to the GetTracksCompilation method.
		GetTracksCompilation []struct {
			// N is the n argument value.
			N int64
			// Strings is the strings argument value.
			Strings []string
		}
		// IncrementListenCount holds details about calls to the IncrementListenCount method.
		IncrementListenCount []struct {
			// N is the n argument value.
			N int64
		}
		// IsPlaylistOwner holds details about calls to the IsPlaylistOwner method.
		IsPlaylistOwner []struct {
			// N1 is the n1 argument value.
			N1 int64
			// N2 is the n2 argument value.
			N2 int64
		}
		// IsPlaylistPublic holds details about calls to the IsPlaylistPublic method.
		IsPlaylistPublic []struct {
			// N is the n argument value.
			N int64
		}
		// IsTrackInFavorites holds details about calls to the IsTrackInFavorites method.
		IsTrackInFavorites []struct {
			// N1 is the n1 argument value.
			N1 int64
			// N2 is the n2 argument value.
			N2 int64
		}
		// PlaylistInfo holds details about calls to the PlaylistInfo method.
		PlaylistInfo []struct {
			// N is the n argument value.
			N int64
		}
		// PlaylistTracks holds details about calls to the PlaylistTracks method.
		PlaylistTracks []struct {
			// N1 is the n1 argument value.
			N1 int64
			// N2 is the n2 argument value.
			N2 int64
		}
		// RandomAlbums holds details about calls to the RandomAlbums method.
		RandomAlbums []struct {
			// N is the n argument value.
			N int64
		}
		// RandomArtists holds details about calls to the RandomArtists method.
		RandomArtists []struct {
			// N is the n argument value.
			N int64
		}
		// RandomTracks holds details about calls to the RandomTracks method.
		RandomTracks []struct {
			// N1 is the n1 argument value.
			N1 int64
			// N2 is the n2 argument value.
			N2 int64
			// B is the b argument value.
			B bool
		}
		// StoreCompilation holds details about calls to the StoreCompilation method.
		StoreCompilation []struct {
			// N is the n argument value.
			N int64
			// Selection is the selection argument value.
			Selection *models.Selection
		}
		// UserPlaylists holds details about calls to the UserPlaylists method.
		UserPlaylists []struct {
			// N is the n argument value.
			N int64
		}
	}
	lockAddTrackToFavorites      sync.RWMutex
	lockAlbumData                sync.RWMutex
	lockAlbumTracks              sync.RWMutex
	lockArtistAlbums             sync.RWMutex
	lockArtistInfo               sync.RWMutex
	lockArtistTracks             sync.RWMutex
	lockDeleteTrackFromFavorites sync.RWMutex
	lockDoesPlaylistExist        sync.RWMutex
	lockFindAlbums               sync.RWMutex
	lockFindArtists              sync.RWMutex
	lockFindTracksByFullWord     sync.RWMutex
	lockFindTracksByPartial      sync.RWMutex
	lockGetCompilation           sync.RWMutex
	lockGetFavoriteTracksID      sync.RWMutex
	lockGetFavorites             sync.RWMutex
	lockGetTracksByID            sync.RWMutex
	lockGetTracksCompilation     sync.RWMutex
	lockIncrementListenCount     sync.RWMutex
	lockIsPlaylistOwner          sync.RWMutex
	lockIsPlaylistPublic         sync.RWMutex
	lockIsTrackInFavorites       sync.RWMutex
	lockPlaylistInfo             sync.RWMutex
	lockPlaylistTracks           sync.RWMutex
	lockRandomAlbums             sync.RWMutex
	lockRandomArtists            sync.RWMutex
	lockRandomTracks             sync.RWMutex
	lockStoreCompilation         sync.RWMutex
	lockUserPlaylists            sync.RWMutex
}

// AddTrackToFavorites calls AddTrackToFavoritesFunc.
func (mock *MockStorage) AddTrackToFavorites(n1 int64, n2 int64) error {
	if mock.AddTrackToFavoritesFunc == nil {
		panic("MockStorage.AddTrackToFavoritesFunc: method is nil but Storage.AddTrackToFavorites was just called")
	}
	callInfo := struct {
		N1 int64
		N2 int64
	}{
		N1: n1,
		N2: n2,
	}
	mock.lockAddTrackToFavorites.Lock()
	mock.calls.AddTrackToFavorites = append(mock.calls.AddTrackToFavorites, callInfo)
	mock.lockAddTrackToFavorites.Unlock()
	return mock.AddTrackToFavoritesFunc(n1, n2)
}

// AddTrackToFavoritesCalls gets all the calls that were made to AddTrackToFavorites.
// Check the length with:
//     len(mockedStorage.AddTrackToFavoritesCalls())
func (mock *MockStorage) AddTrackToFavoritesCalls() []struct {
	N1 int64
	N2 int64
} {
	var calls []struct {
		N1 int64
		N2 int64
	}
	mock.lockAddTrackToFavorites.RLock()
	calls = mock.calls.AddTrackToFavorites
	mock.lockAddTrackToFavorites.RUnlock()
	return calls
}

// AlbumData calls AlbumDataFunc.
func (mock *MockStorage) AlbumData(n int64) (*proto.AlbumPageResponse, error) {
	if mock.AlbumDataFunc == nil {
		panic("MockStorage.AlbumDataFunc: method is nil but Storage.AlbumData was just called")
	}
	callInfo := struct {
		N int64
	}{
		N: n,
	}
	mock.lockAlbumData.Lock()
	mock.calls.AlbumData = append(mock.calls.AlbumData, callInfo)
	mock.lockAlbumData.Unlock()
	return mock.AlbumDataFunc(n)
}

// AlbumDataCalls gets all the calls that were made to AlbumData.
// Check the length with:
//     len(mockedStorage.AlbumDataCalls())
func (mock *MockStorage) AlbumDataCalls() []struct {
	N int64
} {
	var calls []struct {
		N int64
	}
	mock.lockAlbumData.RLock()
	calls = mock.calls.AlbumData
	mock.lockAlbumData.RUnlock()
	return calls
}

// AlbumTracks calls AlbumTracksFunc.
func (mock *MockStorage) AlbumTracks(n1 int64, n2 int64, b bool) ([]*proto.AlbumTrack, error) {
	if mock.AlbumTracksFunc == nil {
		panic("MockStorage.AlbumTracksFunc: method is nil but Storage.AlbumTracks was just called")
	}
	callInfo := struct {
		N1 int64
		N2 int64
		B  bool
	}{
		N1: n1,
		N2: n2,
		B:  b,
	}
	mock.lockAlbumTracks.Lock()
	mock.calls.AlbumTracks = append(mock.calls.AlbumTracks, callInfo)
	mock.lockAlbumTracks.Unlock()
	return mock.AlbumTracksFunc(n1, n2, b)
}

// AlbumTracksCalls gets all the calls that were made to AlbumTracks.
// Check the length with:
//     len(mockedStorage.AlbumTracksCalls())
func (mock *MockStorage) AlbumTracksCalls() []struct {
	N1 int64
	N2 int64
	B  bool
} {
	var calls []struct {
		N1 int64
		N2 int64
		B  bool
	}
	mock.lockAlbumTracks.RLock()
	calls = mock.calls.AlbumTracks
	mock.lockAlbumTracks.RUnlock()
	return calls
}

// ArtistAlbums calls ArtistAlbumsFunc.
func (mock *MockStorage) ArtistAlbums(n1 int64, n2 int64) ([]*proto.Album, error) {
	if mock.ArtistAlbumsFunc == nil {
		panic("MockStorage.ArtistAlbumsFunc: method is nil but Storage.ArtistAlbums was just called")
	}
	callInfo := struct {
		N1 int64
		N2 int64
	}{
		N1: n1,
		N2: n2,
	}
	mock.lockArtistAlbums.Lock()
	mock.calls.ArtistAlbums = append(mock.calls.ArtistAlbums, callInfo)
	mock.lockArtistAlbums.Unlock()
	return mock.ArtistAlbumsFunc(n1, n2)
}

// ArtistAlbumsCalls gets all the calls that were made to ArtistAlbums.
// Check the length with:
//     len(mockedStorage.ArtistAlbumsCalls())
func (mock *MockStorage) ArtistAlbumsCalls() []struct {
	N1 int64
	N2 int64
} {
	var calls []struct {
		N1 int64
		N2 int64
	}
	mock.lockArtistAlbums.RLock()
	calls = mock.calls.ArtistAlbums
	mock.lockArtistAlbums.RUnlock()
	return calls
}

// ArtistInfo calls ArtistInfoFunc.
func (mock *MockStorage) ArtistInfo(n int64) (*proto.Artist, error) {
	if mock.ArtistInfoFunc == nil {
		panic("MockStorage.ArtistInfoFunc: method is nil but Storage.ArtistInfo was just called")
	}
	callInfo := struct {
		N int64
	}{
		N: n,
	}
	mock.lockArtistInfo.Lock()
	mock.calls.ArtistInfo = append(mock.calls.ArtistInfo, callInfo)
	mock.lockArtistInfo.Unlock()
	return mock.ArtistInfoFunc(n)
}

// ArtistInfoCalls gets all the calls that were made to ArtistInfo.
// Check the length with:
//     len(mockedStorage.ArtistInfoCalls())
func (mock *MockStorage) ArtistInfoCalls() []struct {
	N int64
} {
	var calls []struct {
		N int64
	}
	mock.lockArtistInfo.RLock()
	calls = mock.calls.ArtistInfo
	mock.lockArtistInfo.RUnlock()
	return calls
}

// ArtistTracks calls ArtistTracksFunc.
func (mock *MockStorage) ArtistTracks(n1 int64, n2 int64, b bool, n3 int64) ([]*proto.Track, error) {
	if mock.ArtistTracksFunc == nil {
		panic("MockStorage.ArtistTracksFunc: method is nil but Storage.ArtistTracks was just called")
	}
	callInfo := struct {
		N1 int64
		N2 int64
		B  bool
		N3 int64
	}{
		N1: n1,
		N2: n2,
		B:  b,
		N3: n3,
	}
	mock.lockArtistTracks.Lock()
	mock.calls.ArtistTracks = append(mock.calls.ArtistTracks, callInfo)
	mock.lockArtistTracks.Unlock()
	return mock.ArtistTracksFunc(n1, n2, b, n3)
}

// ArtistTracksCalls gets all the calls that were made to ArtistTracks.
// Check the length with:
//     len(mockedStorage.ArtistTracksCalls())
func (mock *MockStorage) ArtistTracksCalls() []struct {
	N1 int64
	N2 int64
	B  bool
	N3 int64
} {
	var calls []struct {
		N1 int64
		N2 int64
		B  bool
		N3 int64
	}
	mock.lockArtistTracks.RLock()
	calls = mock.calls.ArtistTracks
	mock.lockArtistTracks.RUnlock()
	return calls
}

// DeleteTrackFromFavorites calls DeleteTrackFromFavoritesFunc.
func (mock *MockStorage) DeleteTrackFromFavorites(n1 int64, n2 int64) error {
	if mock.DeleteTrackFromFavoritesFunc == nil {
		panic("MockStorage.DeleteTrackFromFavoritesFunc: method is nil but Storage.DeleteTrackFromFavorites was just called")
	}
	callInfo := struct {
		N1 int64
		N2 int64
	}{
		N1: n1,
		N2: n2,
	}
	mock.lockDeleteTrackFromFavorites.Lock()
	mock.calls.DeleteTrackFromFavorites = append(mock.calls.DeleteTrackFromFavorites, callInfo)
	mock.lockDeleteTrackFromFavorites.Unlock()
	return mock.DeleteTrackFromFavoritesFunc(n1, n2)
}

// DeleteTrackFromFavoritesCalls gets all the calls that were made to DeleteTrackFromFavorites.
// Check the length with:
//     len(mockedStorage.DeleteTrackFromFavoritesCalls())
func (mock *MockStorage) DeleteTrackFromFavoritesCalls() []struct {
	N1 int64
	N2 int64
} {
	var calls []struct {
		N1 int64
		N2 int64
	}
	mock.lockDeleteTrackFromFavorites.RLock()
	calls = mock.calls.DeleteTrackFromFavorites
	mock.lockDeleteTrackFromFavorites.RUnlock()
	return calls
}

// DoesPlaylistExist calls DoesPlaylistExistFunc.
func (mock *MockStorage) DoesPlaylistExist(n int64) (bool, error) {
	if mock.DoesPlaylistExistFunc == nil {
		panic("MockStorage.DoesPlaylistExistFunc: method is nil but Storage.DoesPlaylistExist was just called")
	}
	callInfo := struct {
		N int64
	}{
		N: n,
	}
	mock.lockDoesPlaylistExist.Lock()
	mock.calls.DoesPlaylistExist = append(mock.calls.DoesPlaylistExist, callInfo)
	mock.lockDoesPlaylistExist.Unlock()
	return mock.DoesPlaylistExistFunc(n)
}

// DoesPlaylistExistCalls gets all the calls that were made to DoesPlaylistExist.
// Check the length with:
//     len(mockedStorage.DoesPlaylistExistCalls())
func (mock *MockStorage) DoesPlaylistExistCalls() []struct {
	N int64
} {
	var calls []struct {
		N int64
	}
	mock.lockDoesPlaylistExist.RLock()
	calls = mock.calls.DoesPlaylistExist
	mock.lockDoesPlaylistExist.RUnlock()
	return calls
}

// FindAlbums calls FindAlbumsFunc.
func (mock *MockStorage) FindAlbums(s string) ([]*proto.Album, error) {
	if mock.FindAlbumsFunc == nil {
		panic("MockStorage.FindAlbumsFunc: method is nil but Storage.FindAlbums was just called")
	}
	callInfo := struct {
		S string
	}{
		S: s,
	}
	mock.lockFindAlbums.Lock()
	mock.calls.FindAlbums = append(mock.calls.FindAlbums, callInfo)
	mock.lockFindAlbums.Unlock()
	return mock.FindAlbumsFunc(s)
}

// FindAlbumsCalls gets all the calls that were made to FindAlbums.
// Check the length with:
//     len(mockedStorage.FindAlbumsCalls())
func (mock *MockStorage) FindAlbumsCalls() []struct {
	S string
} {
	var calls []struct {
		S string
	}
	mock.lockFindAlbums.RLock()
	calls = mock.calls.FindAlbums
	mock.lockFindAlbums.RUnlock()
	return calls
}

// FindArtists calls FindArtistsFunc.
func (mock *MockStorage) FindArtists(s string) ([]*proto.Artist, error) {
	if mock.FindArtistsFunc == nil {
		panic("MockStorage.FindArtistsFunc: method is nil but Storage.FindArtists was just called")
	}
	callInfo := struct {
		S string
	}{
		S: s,
	}
	mock.lockFindArtists.Lock()
	mock.calls.FindArtists = append(mock.calls.FindArtists, callInfo)
	mock.lockFindArtists.Unlock()
	return mock.FindArtistsFunc(s)
}

// FindArtistsCalls gets all the calls that were made to FindArtists.
// Check the length with:
//     len(mockedStorage.FindArtistsCalls())
func (mock *MockStorage) FindArtistsCalls() []struct {
	S string
} {
	var calls []struct {
		S string
	}
	mock.lockFindArtists.RLock()
	calls = mock.calls.FindArtists
	mock.lockFindArtists.RUnlock()
	return calls
}

// FindTracksByFullWord calls FindTracksByFullWordFunc.
func (mock *MockStorage) FindTracksByFullWord(s string, n int64, b bool) ([]*proto.Track, error) {
	if mock.FindTracksByFullWordFunc == nil {
		panic("MockStorage.FindTracksByFullWordFunc: method is nil but Storage.FindTracksByFullWord was just called")
	}
	callInfo := struct {
		S string
		N int64
		B bool
	}{
		S: s,
		N: n,
		B: b,
	}
	mock.lockFindTracksByFullWord.Lock()
	mock.calls.FindTracksByFullWord = append(mock.calls.FindTracksByFullWord, callInfo)
	mock.lockFindTracksByFullWord.Unlock()
	return mock.FindTracksByFullWordFunc(s, n, b)
}

// FindTracksByFullWordCalls gets all the calls that were made to FindTracksByFullWord.
// Check the length with:
//     len(mockedStorage.FindTracksByFullWordCalls())
func (mock *MockStorage) FindTracksByFullWordCalls() []struct {
	S string
	N int64
	B bool
} {
	var calls []struct {
		S string
		N int64
		B bool
	}
	mock.lockFindTracksByFullWord.RLock()
	calls = mock.calls.FindTracksByFullWord
	mock.lockFindTracksByFullWord.RUnlock()
	return calls
}

// FindTracksByPartial calls FindTracksByPartialFunc.
func (mock *MockStorage) FindTracksByPartial(s string, n int64, b bool) ([]*proto.Track, error) {
	if mock.FindTracksByPartialFunc == nil {
		panic("MockStorage.FindTracksByPartialFunc: method is nil but Storage.FindTracksByPartial was just called")
	}
	callInfo := struct {
		S string
		N int64
		B bool
	}{
		S: s,
		N: n,
		B: b,
	}
	mock.lockFindTracksByPartial.Lock()
	mock.calls.FindTracksByPartial = append(mock.calls.FindTracksByPartial, callInfo)
	mock.lockFindTracksByPartial.Unlock()
	return mock.FindTracksByPartialFunc(s, n, b)
}

// FindTracksByPartialCalls gets all the calls that were made to FindTracksByPartial.
// Check the length with:
//     len(mockedStorage.FindTracksByPartialCalls())
func (mock *MockStorage) FindTracksByPartialCalls() []struct {
	S string
	N int64
	B bool
} {
	var calls []struct {
		S string
		N int64
		B bool
	}
	mock.lockFindTracksByPartial.RLock()
	calls = mock.calls.FindTracksByPartial
	mock.lockFindTracksByPartial.RUnlock()
	return calls
}

// GetCompilation calls GetCompilationFunc.
func (mock *MockStorage) GetCompilation(n int64) (*models.Selection, error) {
	if mock.GetCompilationFunc == nil {
		panic("MockStorage.GetCompilationFunc: method is nil but Storage.GetCompilation was just called")
	}
	callInfo := struct {
		N int64
	}{
		N: n,
	}
	mock.lockGetCompilation.Lock()
	mock.calls.GetCompilation = append(mock.calls.GetCompilation, callInfo)
	mock.lockGetCompilation.Unlock()
	return mock.GetCompilationFunc(n)
}

// GetCompilationCalls gets all the calls that were made to GetCompilation.
// Check the length with:
//     len(mockedStorage.GetCompilationCalls())
func (mock *MockStorage) GetCompilationCalls() []struct {
	N int64
} {
	var calls []struct {
		N int64
	}
	mock.lockGetCompilation.RLock()
	calls = mock.calls.GetCompilation
	mock.lockGetCompilation.RUnlock()
	return calls
}

// GetFavoriteTracksID calls GetFavoriteTracksIDFunc.
func (mock *MockStorage) GetFavoriteTracksID(n int64) ([]string, error) {
	if mock.GetFavoriteTracksIDFunc == nil {
		panic("MockStorage.GetFavoriteTracksIDFunc: method is nil but Storage.GetFavoriteTracksID was just called")
	}
	callInfo := struct {
		N int64
	}{
		N: n,
	}
	mock.lockGetFavoriteTracksID.Lock()
	mock.calls.GetFavoriteTracksID = append(mock.calls.GetFavoriteTracksID, callInfo)
	mock.lockGetFavoriteTracksID.Unlock()
	return mock.GetFavoriteTracksIDFunc(n)
}

// GetFavoriteTracksIDCalls gets all the calls that were made to GetFavoriteTracksID.
// Check the length with:
//     len(mockedStorage.GetFavoriteTracksIDCalls())
func (mock *MockStorage) GetFavoriteTracksIDCalls() []struct {
	N int64
} {
	var calls []struct {
		N int64
	}
	mock.lockGetFavoriteTracksID.RLock()
	calls = mock.calls.GetFavoriteTracksID
	mock.lockGetFavoriteTracksID.RUnlock()
	return calls
}

// GetFavorites calls GetFavoritesFunc.
func (mock *MockStorage) GetFavorites(n int64) ([]*proto.Track, error) {
	if mock.GetFavoritesFunc == nil {
		panic("MockStorage.GetFavoritesFunc: method is nil but Storage.GetFavorites was just called")
	}
	callInfo := struct {
		N int64
	}{
		N: n,
	}
	mock.lockGetFavorites.Lock()
	mock.calls.GetFavorites = append(mock.calls.GetFavorites, callInfo)
	mock.lockGetFavorites.Unlock()
	return mock.GetFavoritesFunc(n)
}

// GetFavoritesCalls gets all the calls that were made to GetFavorites.
// Check the length with:
//     len(mockedStorage.GetFavoritesCalls())
func (mock *MockStorage) GetFavoritesCalls() []struct {
	N int64
} {
	var calls []struct {
		N int64
	}
	mock.lockGetFavorites.RLock()
	calls = mock.calls.GetFavorites
	mock.lockGetFavorites.RUnlock()
	return calls
}

// GetTracksByID calls GetTracksByIDFunc.
func (mock *MockStorage) GetTracksByID(strings []string, n int64, b bool) ([]*proto.Track, error) {
	if mock.GetTracksByIDFunc == nil {
		panic("MockStorage.GetTracksByIDFunc: method is nil but Storage.GetTracksByID was just called")
	}
	callInfo := struct {
		Strings []string
		N       int64
		B       bool
	}{
		Strings: strings,
		N:       n,
		B:       b,
	}
	mock.lockGetTracksByID.Lock()
	mock.calls.GetTracksByID = append(mock.calls.GetTracksByID, callInfo)
	mock.lockGetTracksByID.Unlock()
	return mock.GetTracksByIDFunc(strings, n, b)
}

// GetTracksByIDCalls gets all the calls that were made to GetTracksByID.
// Check the length with:
//     len(mockedStorage.GetTracksByIDCalls())
func (mock *MockStorage) GetTracksByIDCalls() []struct {
	Strings []string
	N       int64
	B       bool
} {
	var calls []struct {
		Strings []string
		N       int64
		B       bool
	}
	mock.lockGetTracksByID.RLock()
	calls = mock.calls.GetTracksByID
	mock.lockGetTracksByID.RUnlock()
	return calls
}

// GetTracksCompilation calls GetTracksCompilationFunc.
func (mock *MockStorage) GetTracksCompilation(n int64, strings []string) ([]string, error) {
	if mock.GetTracksCompilationFunc == nil {
		panic("MockStorage.GetTracksCompilationFunc: method is nil but Storage.GetTracksCompilation was just called")
	}
	callInfo := struct {
		N       int64
		Strings []string
	}{
		N:       n,
		Strings: strings,
	}
	mock.lockGetTracksCompilation.Lock()
	mock.calls.GetTracksCompilation = append(mock.calls.GetTracksCompilation, callInfo)
	mock.lockGetTracksCompilation.Unlock()
	return mock.GetTracksCompilationFunc(n, strings)
}

// GetTracksCompilationCalls gets all the calls that were made to GetTracksCompilation.
// Check the length with:
//     len(mockedStorage.GetTracksCompilationCalls())
func (mock *MockStorage) GetTracksCompilationCalls() []struct {
	N       int64
	Strings []string
} {
	var calls []struct {
		N       int64
		Strings []string
	}
	mock.lockGetTracksCompilation.RLock()
	calls = mock.calls.GetTracksCompilation
	mock.lockGetTracksCompilation.RUnlock()
	return calls
}

// IncrementListenCount calls IncrementListenCountFunc.
func (mock *MockStorage) IncrementListenCount(n int64) error {
	if mock.IncrementListenCountFunc == nil {
		panic("MockStorage.IncrementListenCountFunc: method is nil but Storage.IncrementListenCount was just called")
	}
	callInfo := struct {
		N int64
	}{
		N: n,
	}
	mock.lockIncrementListenCount.Lock()
	mock.calls.IncrementListenCount = append(mock.calls.IncrementListenCount, callInfo)
	mock.lockIncrementListenCount.Unlock()
	return mock.IncrementListenCountFunc(n)
}

// IncrementListenCountCalls gets all the calls that were made to IncrementListenCount.
// Check the length with:
//     len(mockedStorage.IncrementListenCountCalls())
func (mock *MockStorage) IncrementListenCountCalls() []struct {
	N int64
} {
	var calls []struct {
		N int64
	}
	mock.lockIncrementListenCount.RLock()
	calls = mock.calls.IncrementListenCount
	mock.lockIncrementListenCount.RUnlock()
	return calls
}

// IsPlaylistOwner calls IsPlaylistOwnerFunc.
func (mock *MockStorage) IsPlaylistOwner(n1 int64, n2 int64) (bool, error) {
	if mock.IsPlaylistOwnerFunc == nil {
		panic("MockStorage.IsPlaylistOwnerFunc: method is nil but Storage.IsPlaylistOwner was just called")
	}
	callInfo := struct {
		N1 int64
		N2 int64
	}{
		N1: n1,
		N2: n2,
	}
	mock.lockIsPlaylistOwner.Lock()
	mock.calls.IsPlaylistOwner = append(mock.calls.IsPlaylistOwner, callInfo)
	mock.lockIsPlaylistOwner.Unlock()
	return mock.IsPlaylistOwnerFunc(n1, n2)
}

// IsPlaylistOwnerCalls gets all the calls that were made to IsPlaylistOwner.
// Check the length with:
//     len(mockedStorage.IsPlaylistOwnerCalls())
func (mock *MockStorage) IsPlaylistOwnerCalls() []struct {
	N1 int64
	N2 int64
} {
	var calls []struct {
		N1 int64
		N2 int64
	}
	mock.lockIsPlaylistOwner.RLock()
	calls = mock.calls.IsPlaylistOwner
	mock.lockIsPlaylistOwner.RUnlock()
	return calls
}

// IsPlaylistPublic calls IsPlaylistPublicFunc.
func (mock *MockStorage) IsPlaylistPublic(n int64) (bool, error) {
	if mock.IsPlaylistPublicFunc == nil {
		panic("MockStorage.IsPlaylistPublicFunc: method is nil but Storage.IsPlaylistPublic was just called")
	}
	callInfo := struct {
		N int64
	}{
		N: n,
	}
	mock.lockIsPlaylistPublic.Lock()
	mock.calls.IsPlaylistPublic = append(mock.calls.IsPlaylistPublic, callInfo)
	mock.lockIsPlaylistPublic.Unlock()
	return mock.IsPlaylistPublicFunc(n)
}

// IsPlaylistPublicCalls gets all the calls that were made to IsPlaylistPublic.
// Check the length with:
//     len(mockedStorage.IsPlaylistPublicCalls())
func (mock *MockStorage) IsPlaylistPublicCalls() []struct {
	N int64
} {
	var calls []struct {
		N int64
	}
	mock.lockIsPlaylistPublic.RLock()
	calls = mock.calls.IsPlaylistPublic
	mock.lockIsPlaylistPublic.RUnlock()
	return calls
}

// IsTrackInFavorites calls IsTrackInFavoritesFunc.
func (mock *MockStorage) IsTrackInFavorites(n1 int64, n2 int64) (bool, error) {
	if mock.IsTrackInFavoritesFunc == nil {
		panic("MockStorage.IsTrackInFavoritesFunc: method is nil but Storage.IsTrackInFavorites was just called")
	}
	callInfo := struct {
		N1 int64
		N2 int64
	}{
		N1: n1,
		N2: n2,
	}
	mock.lockIsTrackInFavorites.Lock()
	mock.calls.IsTrackInFavorites = append(mock.calls.IsTrackInFavorites, callInfo)
	mock.lockIsTrackInFavorites.Unlock()
	return mock.IsTrackInFavoritesFunc(n1, n2)
}

// IsTrackInFavoritesCalls gets all the calls that were made to IsTrackInFavorites.
// Check the length with:
//     len(mockedStorage.IsTrackInFavoritesCalls())
func (mock *MockStorage) IsTrackInFavoritesCalls() []struct {
	N1 int64
	N2 int64
} {
	var calls []struct {
		N1 int64
		N2 int64
	}
	mock.lockIsTrackInFavorites.RLock()
	calls = mock.calls.IsTrackInFavorites
	mock.lockIsTrackInFavorites.RUnlock()
	return calls
}

// PlaylistInfo calls PlaylistInfoFunc.
func (mock *MockStorage) PlaylistInfo(n int64) (*proto.PlaylistData, error) {
	if mock.PlaylistInfoFunc == nil {
		panic("MockStorage.PlaylistInfoFunc: method is nil but Storage.PlaylistInfo was just called")
	}
	callInfo := struct {
		N int64
	}{
		N: n,
	}
	mock.lockPlaylistInfo.Lock()
	mock.calls.PlaylistInfo = append(mock.calls.PlaylistInfo, callInfo)
	mock.lockPlaylistInfo.Unlock()
	return mock.PlaylistInfoFunc(n)
}

// PlaylistInfoCalls gets all the calls that were made to PlaylistInfo.
// Check the length with:
//     len(mockedStorage.PlaylistInfoCalls())
func (mock *MockStorage) PlaylistInfoCalls() []struct {
	N int64
} {
	var calls []struct {
		N int64
	}
	mock.lockPlaylistInfo.RLock()
	calls = mock.calls.PlaylistInfo
	mock.lockPlaylistInfo.RUnlock()
	return calls
}

// PlaylistTracks calls PlaylistTracksFunc.
func (mock *MockStorage) PlaylistTracks(n1 int64, n2 int64) ([]*proto.Track, error) {
	if mock.PlaylistTracksFunc == nil {
		panic("MockStorage.PlaylistTracksFunc: method is nil but Storage.PlaylistTracks was just called")
	}
	callInfo := struct {
		N1 int64
		N2 int64
	}{
		N1: n1,
		N2: n2,
	}
	mock.lockPlaylistTracks.Lock()
	mock.calls.PlaylistTracks = append(mock.calls.PlaylistTracks, callInfo)
	mock.lockPlaylistTracks.Unlock()
	return mock.PlaylistTracksFunc(n1, n2)
}

// PlaylistTracksCalls gets all the calls that were made to PlaylistTracks.
// Check the length with:
//     len(mockedStorage.PlaylistTracksCalls())
func (mock *MockStorage) PlaylistTracksCalls() []struct {
	N1 int64
	N2 int64
} {
	var calls []struct {
		N1 int64
		N2 int64
	}
	mock.lockPlaylistTracks.RLock()
	calls = mock.calls.PlaylistTracks
	mock.lockPlaylistTracks.RUnlock()
	return calls
}

// RandomAlbums calls RandomAlbumsFunc.
func (mock *MockStorage) RandomAlbums(n int64) (*proto.Albums, error) {
	if mock.RandomAlbumsFunc == nil {
		panic("MockStorage.RandomAlbumsFunc: method is nil but Storage.RandomAlbums was just called")
	}
	callInfo := struct {
		N int64
	}{
		N: n,
	}
	mock.lockRandomAlbums.Lock()
	mock.calls.RandomAlbums = append(mock.calls.RandomAlbums, callInfo)
	mock.lockRandomAlbums.Unlock()
	return mock.RandomAlbumsFunc(n)
}

// RandomAlbumsCalls gets all the calls that were made to RandomAlbums.
// Check the length with:
//     len(mockedStorage.RandomAlbumsCalls())
func (mock *MockStorage) RandomAlbumsCalls() []struct {
	N int64
} {
	var calls []struct {
		N int64
	}
	mock.lockRandomAlbums.RLock()
	calls = mock.calls.RandomAlbums
	mock.lockRandomAlbums.RUnlock()
	return calls
}

// RandomArtists calls RandomArtistsFunc.
func (mock *MockStorage) RandomArtists(n int64) (*proto.Artists, error) {
	if mock.RandomArtistsFunc == nil {
		panic("MockStorage.RandomArtistsFunc: method is nil but Storage.RandomArtists was just called")
	}
	callInfo := struct {
		N int64
	}{
		N: n,
	}
	mock.lockRandomArtists.Lock()
	mock.calls.RandomArtists = append(mock.calls.RandomArtists, callInfo)
	mock.lockRandomArtists.Unlock()
	return mock.RandomArtistsFunc(n)
}

// RandomArtistsCalls gets all the calls that were made to RandomArtists.
// Check the length with:
//     len(mockedStorage.RandomArtistsCalls())
func (mock *MockStorage) RandomArtistsCalls() []struct {
	N int64
} {
	var calls []struct {
		N int64
	}
	mock.lockRandomArtists.RLock()
	calls = mock.calls.RandomArtists
	mock.lockRandomArtists.RUnlock()
	return calls
}

// RandomTracks calls RandomTracksFunc.
func (mock *MockStorage) RandomTracks(n1 int64, n2 int64, b bool) ([]*proto.Track, error) {
	if mock.RandomTracksFunc == nil {
		panic("MockStorage.RandomTracksFunc: method is nil but Storage.RandomTracks was just called")
	}
	callInfo := struct {
		N1 int64
		N2 int64
		B  bool
	}{
		N1: n1,
		N2: n2,
		B:  b,
	}
	mock.lockRandomTracks.Lock()
	mock.calls.RandomTracks = append(mock.calls.RandomTracks, callInfo)
	mock.lockRandomTracks.Unlock()
	return mock.RandomTracksFunc(n1, n2, b)
}

// RandomTracksCalls gets all the calls that were made to RandomTracks.
// Check the length with:
//     len(mockedStorage.RandomTracksCalls())
func (mock *MockStorage) RandomTracksCalls() []struct {
	N1 int64
	N2 int64
	B  bool
} {
	var calls []struct {
		N1 int64
		N2 int64
		B  bool
	}
	mock.lockRandomTracks.RLock()
	calls = mock.calls.RandomTracks
	mock.lockRandomTracks.RUnlock()
	return calls
}

// StoreCompilation calls StoreCompilationFunc.
func (mock *MockStorage) StoreCompilation(n int64, selection *models.Selection) error {
	if mock.StoreCompilationFunc == nil {
		panic("MockStorage.StoreCompilationFunc: method is nil but Storage.StoreCompilation was just called")
	}
	callInfo := struct {
		N         int64
		Selection *models.Selection
	}{
		N:         n,
		Selection: selection,
	}
	mock.lockStoreCompilation.Lock()
	mock.calls.StoreCompilation = append(mock.calls.StoreCompilation, callInfo)
	mock.lockStoreCompilation.Unlock()
	return mock.StoreCompilationFunc(n, selection)
}

// StoreCompilationCalls gets all the calls that were made to StoreCompilation.
// Check the length with:
//     len(mockedStorage.StoreCompilationCalls())
func (mock *MockStorage) StoreCompilationCalls() []struct {
	N         int64
	Selection *models.Selection
} {
	var calls []struct {
		N         int64
		Selection *models.Selection
	}
	mock.lockStoreCompilation.RLock()
	calls = mock.calls.StoreCompilation
	mock.lockStoreCompilation.RUnlock()
	return calls
}

// UserPlaylists calls UserPlaylistsFunc.
func (mock *MockStorage) UserPlaylists(n int64) ([]*proto.PlaylistData, error) {
	if mock.UserPlaylistsFunc == nil {
		panic("MockStorage.UserPlaylistsFunc: method is nil but Storage.UserPlaylists was just called")
	}
	callInfo := struct {
		N int64
	}{
		N: n,
	}
	mock.lockUserPlaylists.Lock()
	mock.calls.UserPlaylists = append(mock.calls.UserPlaylists, callInfo)
	mock.lockUserPlaylists.Unlock()
	return mock.UserPlaylistsFunc(n)
}

// UserPlaylistsCalls gets all the calls that were made to UserPlaylists.
// Check the length with:
//     len(mockedStorage.UserPlaylistsCalls())
func (mock *MockStorage) UserPlaylistsCalls() []struct {
	N int64
} {
	var calls []struct {
		N int64
	}
	mock.lockUserPlaylists.RLock()
	calls = mock.calls.UserPlaylists
	mock.lockUserPlaylists.RUnlock()
	return calls
}
