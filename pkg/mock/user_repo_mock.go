// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"2021_2_LostPointer/pkg/models"
	"2021_2_LostPointer/pkg/users"
	"sync"
)

// Ensure, that MockUserRepository does implement users.UserRepository.
// If this is not the case, regenerate this file with moq.
var _ users.UserRepository = &MockUserRepository{}

// MockUserRepository is a mock implementation of users.UserRepository.
//
// 	func TestSomethingThatUsesUserRepository(t *testing.T) {
//
// 		// make and configure a mocked users.UserRepository
// 		mockedUserRepository := &MockUserRepository{
// 			CreateUserFunc: func(user models.User, strings ...string) (uint64, error) {
// 				panic("mock out the CreateUser method")
// 			},
// 			IsEmailUniqueFunc: func(s string) (bool, error) {
// 				panic("mock out the IsEmailUnique method")
// 			},
// 			IsNicknameUniqueFunc: func(s string) (bool, error) {
// 				panic("mock out the IsNicknameUnique method")
// 			},
// 			UserExitsFunc: func(auth models.Auth) (uint64, error) {
// 				panic("mock out the UserExits method")
// 			},
// 		}
//
// 		// use mockedUserRepository in code that requires users.UserRepository
// 		// and then make assertions.
//
// 	}
type MockUserRepository struct {
	// CreateUserFunc mocks the CreateUser method.
	CreateUserFunc func(user models.User, strings ...string) (uint64, error)

	// IsEmailUniqueFunc mocks the IsEmailUnique method.
	IsEmailUniqueFunc func(s string) (bool, error)

	// IsNicknameUniqueFunc mocks the IsNicknameUnique method.
	IsNicknameUniqueFunc func(s string) (bool, error)

	// UserExitsFunc mocks the UserExits method.
	UserExitsFunc func(auth models.Auth) (uint64, error)

	// calls tracks calls to the methods.
	calls struct {
		// CreateUser holds details about calls to the CreateUser method.
		CreateUser []struct {
			// User is the user argument value.
			User models.User
			// Strings is the strings argument value.
			Strings []string
		}
		// IsEmailUnique holds details about calls to the IsEmailUnique method.
		IsEmailUnique []struct {
			// S is the s argument value.
			S string
		}
		// IsNicknameUnique holds details about calls to the IsNicknameUnique method.
		IsNicknameUnique []struct {
			// S is the s argument value.
			S string
		}
		// UserExits holds details about calls to the UserExits method.
		UserExits []struct {
			// Auth is the auth argument value.
			Auth models.Auth
		}
	}
	lockCreateUser       sync.RWMutex
	lockIsEmailUnique    sync.RWMutex
	lockIsNicknameUnique sync.RWMutex
	lockUserExits        sync.RWMutex
}

// CreateUser calls CreateUserFunc.
func (mock *MockUserRepository) CreateUser(user models.User, strings ...string) (uint64, error) {
	if mock.CreateUserFunc == nil {
		panic("MockUserRepository.CreateUserFunc: method is nil but UserRepository.CreateUser was just called")
	}
	callInfo := struct {
		User    models.User
		Strings []string
	}{
		User:    user,
		Strings: strings,
	}
	mock.lockCreateUser.Lock()
	mock.calls.CreateUser = append(mock.calls.CreateUser, callInfo)
	mock.lockCreateUser.Unlock()
	return mock.CreateUserFunc(user, strings...)
}

// CreateUserCalls gets all the calls that were made to CreateUser.
// Check the length with:
//     len(mockedUserRepository.CreateUserCalls())
func (mock *MockUserRepository) CreateUserCalls() []struct {
	User    models.User
	Strings []string
} {
	var calls []struct {
		User    models.User
		Strings []string
	}
	mock.lockCreateUser.RLock()
	calls = mock.calls.CreateUser
	mock.lockCreateUser.RUnlock()
	return calls
}

// IsEmailUnique calls IsEmailUniqueFunc.
func (mock *MockUserRepository) IsEmailUnique(s string) (bool, error) {
	if mock.IsEmailUniqueFunc == nil {
		panic("MockUserRepository.IsEmailUniqueFunc: method is nil but UserRepository.IsEmailUnique was just called")
	}
	callInfo := struct {
		S string
	}{
		S: s,
	}
	mock.lockIsEmailUnique.Lock()
	mock.calls.IsEmailUnique = append(mock.calls.IsEmailUnique, callInfo)
	mock.lockIsEmailUnique.Unlock()
	return mock.IsEmailUniqueFunc(s)
}

// IsEmailUniqueCalls gets all the calls that were made to IsEmailUnique.
// Check the length with:
//     len(mockedUserRepository.IsEmailUniqueCalls())
func (mock *MockUserRepository) IsEmailUniqueCalls() []struct {
	S string
} {
	var calls []struct {
		S string
	}
	mock.lockIsEmailUnique.RLock()
	calls = mock.calls.IsEmailUnique
	mock.lockIsEmailUnique.RUnlock()
	return calls
}

// IsNicknameUnique calls IsNicknameUniqueFunc.
func (mock *MockUserRepository) IsNicknameUnique(s string) (bool, error) {
	if mock.IsNicknameUniqueFunc == nil {
		panic("MockUserRepository.IsNicknameUniqueFunc: method is nil but UserRepository.IsNicknameUnique was just called")
	}
	callInfo := struct {
		S string
	}{
		S: s,
	}
	mock.lockIsNicknameUnique.Lock()
	mock.calls.IsNicknameUnique = append(mock.calls.IsNicknameUnique, callInfo)
	mock.lockIsNicknameUnique.Unlock()
	return mock.IsNicknameUniqueFunc(s)
}

// IsNicknameUniqueCalls gets all the calls that were made to IsNicknameUnique.
// Check the length with:
//     len(mockedUserRepository.IsNicknameUniqueCalls())
func (mock *MockUserRepository) IsNicknameUniqueCalls() []struct {
	S string
} {
	var calls []struct {
		S string
	}
	mock.lockIsNicknameUnique.RLock()
	calls = mock.calls.IsNicknameUnique
	mock.lockIsNicknameUnique.RUnlock()
	return calls
}

// UserExits calls UserExitsFunc.
func (mock *MockUserRepository) UserExits(auth models.Auth) (uint64, error) {
	if mock.UserExitsFunc == nil {
		panic("MockUserRepository.UserExitsFunc: method is nil but UserRepository.UserExits was just called")
	}
	callInfo := struct {
		Auth models.Auth
	}{
		Auth: auth,
	}
	mock.lockUserExits.Lock()
	mock.calls.UserExits = append(mock.calls.UserExits, callInfo)
	mock.lockUserExits.Unlock()
	return mock.UserExitsFunc(auth)
}

// UserExitsCalls gets all the calls that were made to UserExits.
// Check the length with:
//     len(mockedUserRepository.UserExitsCalls())
func (mock *MockUserRepository) UserExitsCalls() []struct {
	Auth models.Auth
} {
	var calls []struct {
		Auth models.Auth
	}
	mock.lockUserExits.RLock()
	calls = mock.calls.UserExits
	mock.lockUserExits.RUnlock()
	return calls
}
