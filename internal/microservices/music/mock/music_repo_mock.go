// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"2021_2_LostPointer/internal/microservices/music"
	"2021_2_LostPointer/internal/microservices/music/proto"
	"sync"
)

// Ensure, that MockStorage does implement music.Storage.
// If this is not the case, regenerate this file with moq.
var _ music.Storage = &MockStorage{}

// MockStorage is a mock implementation of music.Storage.
//
// 	func TestSomethingThatUsesStorage(t *testing.T) {
//
// 		// make and configure a mocked music.Storage
// 		mockedStorage := &MockStorage{
// 			AddTrackToFavoriteFunc: func(userID int64, trackID int64) error {
// 				panic("mock out the AddTrackToFavorite method")
// 			},
// 			AlbumDataFunc: func(n int64) (*proto.AlbumPageResponse, error) {
// 				panic("mock out the AlbumData method")
// 			},
// 			AlbumTracksFunc: func(n1 int64, n2 int64, b bool) ([]*proto.AlbumTrack, error) {
// 				panic("mock out the AlbumTracks method")
// 			},
// 			ArtistAlbumsFunc: func(n1 int64, n2 int64) ([]*proto.Album, error) {
// 				panic("mock out the ArtistAlbums method")
// 			},
// 			ArtistInfoFunc: func(n int64) (*proto.Artist, error) {
// 				panic("mock out the ArtistInfo method")
// 			},
// 			ArtistTracksFunc: func(n1 int64, n2 int64, b bool, n3 int64) ([]*proto.Track, error) {
// 				panic("mock out the ArtistTracks method")
// 			},
// 			DeleteTrackFromFavoritesFunc: func(userID int64, trackID int64) error {
// 				panic("mock out the DeleteTrackFromFavorites method")
// 			},
// 			DoesPlaylistExistFunc: func(n int64) (bool, error) {
// 				panic("mock out the DoesPlaylistExist method")
// 			},
// 			FindAlbumsFunc: func(s string) ([]*proto.Album, error) {
// 				panic("mock out the FindAlbums method")
// 			},
// 			FindArtistsFunc: func(s string) ([]*proto.Artist, error) {
// 				panic("mock out the FindArtists method")
// 			},
// 			FindTracksByFullWordFunc: func(s string, n int64, b bool) ([]*proto.Track, error) {
// 				panic("mock out the FindTracksByFullWord method")
// 			},
// 			FindTracksByPartialFunc: func(s string, n int64, b bool) ([]*proto.Track, error) {
// 				panic("mock out the FindTracksByPartial method")
// 			},
// 			GetFavoritesFunc: func(userID int64) ([]*proto.Track, error) {
// 				panic("mock out the GetFavorites method")
// 			},
// 			IncrementListenCountFunc: func(n int64) error {
// 				panic("mock out the IncrementListenCount method")
// 			},
// 			IsPlaylistOwnerFunc: func(n1 int64, n2 int64) (bool, error) {
// 				panic("mock out the IsPlaylistOwner method")
// 			},
// 			IsPlaylistPublicFunc: func(n int64) (bool, error) {
// 				panic("mock out the IsPlaylistPublic method")
// 			},
// 			IsTrackInFavoritesFunc: func(userID int64, trackID int64) (bool, error) {
// 				panic("mock out the IsTrackInFavorites method")
// 			},
// 			PlaylistInfoFunc: func(n int64) (*proto.PlaylistData, error) {
// 				panic("mock out the PlaylistInfo method")
// 			},
// 			PlaylistTracksFunc: func(n1 int64, n2 int64) ([]*proto.Track, error) {
// 				panic("mock out the PlaylistTracks method")
// 			},
// 			RandomAlbumsFunc: func(n int64) (*proto.Albums, error) {
// 				panic("mock out the RandomAlbums method")
// 			},
// 			RandomArtistsFunc: func(n int64) (*proto.Artists, error) {
// 				panic("mock out the RandomArtists method")
// 			},
// 			RandomTracksFunc: func(n1 int64, n2 int64, b bool) (*proto.Tracks, error) {
// 				panic("mock out the RandomTracks method")
// 			},
// 			UserPlaylistsFunc: func(n int64) ([]*proto.PlaylistData, error) {
// 				panic("mock out the UserPlaylists method")
// 			},
// 		}
//
// 		// use mockedStorage in code that requires music.Storage
// 		// and then make assertions.
//
// 	}
type MockStorage struct {
	// AddTrackToFavoriteFunc mocks the AddTrackToFavorite method.
	AddTrackToFavoriteFunc func(userID int64, trackID int64) error

	// AlbumDataFunc mocks the AlbumData method.
	AlbumDataFunc func(n int64) (*proto.AlbumPageResponse, error)

	// AlbumTracksFunc mocks the AlbumTracks method.
	AlbumTracksFunc func(n1 int64, n2 int64, b bool) ([]*proto.AlbumTrack, error)

	// ArtistAlbumsFunc mocks the ArtistAlbums method.
	ArtistAlbumsFunc func(n1 int64, n2 int64) ([]*proto.Album, error)

	// ArtistInfoFunc mocks the ArtistInfo method.
	ArtistInfoFunc func(n int64) (*proto.Artist, error)

	// ArtistTracksFunc mocks the ArtistTracks method.
	ArtistTracksFunc func(n1 int64, n2 int64, b bool, n3 int64) ([]*proto.Track, error)

	// DeleteTrackFromFavoritesFunc mocks the DeleteTrackFromFavorites method.
	DeleteTrackFromFavoritesFunc func(userID int64, trackID int64) error

	// DoesPlaylistExistFunc mocks the DoesPlaylistExist method.
	DoesPlaylistExistFunc func(n int64) (bool, error)

	// FindAlbumsFunc mocks the FindAlbums method.
	FindAlbumsFunc func(s string) ([]*proto.Album, error)

	// FindArtistsFunc mocks the FindArtists method.
	FindArtistsFunc func(s string) ([]*proto.Artist, error)

	// FindTracksByFullWordFunc mocks the FindTracksByFullWord method.
	FindTracksByFullWordFunc func(s string, n int64, b bool) ([]*proto.Track, error)

	// FindTracksByPartialFunc mocks the FindTracksByPartial method.
	FindTracksByPartialFunc func(s string, n int64, b bool) ([]*proto.Track, error)

	// GetFavoritesFunc mocks the GetFavorites method.
	GetFavoritesFunc func(userID int64) ([]*proto.Track, error)

	// IncrementListenCountFunc mocks the IncrementListenCount method.
	IncrementListenCountFunc func(n int64) error

	// IsPlaylistOwnerFunc mocks the IsPlaylistOwner method.
	IsPlaylistOwnerFunc func(n1 int64, n2 int64) (bool, error)

	// IsPlaylistPublicFunc mocks the IsPlaylistPublic method.
	IsPlaylistPublicFunc func(n int64) (bool, error)

	// IsTrackInFavoritesFunc mocks the IsTrackInFavorites method.
	IsTrackInFavoritesFunc func(userID int64, trackID int64) (bool, error)

	// PlaylistInfoFunc mocks the PlaylistInfo method.
	PlaylistInfoFunc func(n int64) (*proto.PlaylistData, error)

	// PlaylistTracksFunc mocks the PlaylistTracks method.
	PlaylistTracksFunc func(n1 int64, n2 int64) ([]*proto.Track, error)

	// RandomAlbumsFunc mocks the RandomAlbums method.
	RandomAlbumsFunc func(n int64) (*proto.Albums, error)

	// RandomArtistsFunc mocks the RandomArtists method.
	RandomArtistsFunc func(n int64) (*proto.Artists, error)

	// RandomTracksFunc mocks the RandomTracks method.
	RandomTracksFunc func(n1 int64, n2 int64, b bool) (*proto.Tracks, error)

	// UserPlaylistsFunc mocks the UserPlaylists method.
	UserPlaylistsFunc func(n int64) ([]*proto.PlaylistData, error)

	// calls tracks calls to the methods.
	calls struct {
		// AddTrackToFavorite holds details about calls to the AddTrackToFavorite method.
		AddTrackToFavorite []struct {
			// UserID is the userID argument value.
			UserID int64
			// TrackID is the trackID argument value.
			TrackID int64
		}
		// AlbumData holds details about calls to the AlbumData method.
		AlbumData []struct {
			// N is the n argument value.
			N int64
		}
		// AlbumTracks holds details about calls to the AlbumTracks method.
		AlbumTracks []struct {
			// N1 is the n1 argument value.
			N1 int64
			// N2 is the n2 argument value.
			N2 int64
			// B is the b argument value.
			B bool
		}
		// ArtistAlbums holds details about calls to the ArtistAlbums method.
		ArtistAlbums []struct {
			// N1 is the n1 argument value.
			N1 int64
			// N2 is the n2 argument value.
			N2 int64
		}
		// ArtistInfo holds details about calls to the ArtistInfo method.
		ArtistInfo []struct {
			// N is the n argument value.
			N int64
		}
		// ArtistTracks holds details about calls to the ArtistTracks method.
		ArtistTracks []struct {
			// N1 is the n1 argument value.
			N1 int64
			// N2 is the n2 argument value.
			N2 int64
			// B is the b argument value.
			B bool
			// N3 is the n3 argument value.
			N3 int64
		}
		// DeleteTrackFromFavorites holds details about calls to the DeleteTrackFromFavorites method.
		DeleteTrackFromFavorites []struct {
			// UserID is the userID argument value.
			UserID int64
			// TrackID is the trackID argument value.
			TrackID int64
		}
		// DoesPlaylistExist holds details about calls to the DoesPlaylistExist method.
		DoesPlaylistExist []struct {
			// N is the n argument value.
			N int64
		}
		// FindAlbums holds details about calls to the FindAlbums method.
		FindAlbums []struct {
			// S is the s argument value.
			S string
		}
		// FindArtists holds details about calls to the FindArtists method.
		FindArtists []struct {
			// S is the s argument value.
			S string
		}
		// FindTracksByFullWord holds details about calls to the FindTracksByFullWord method.
		FindTracksByFullWord []struct {
			// S is the s argument value.
			S string
			// N is the n argument value.
			N int64
			// B is the b argument value.
			B bool
		}
		// FindTracksByPartial holds details about calls to the FindTracksByPartial method.
		FindTracksByPartial []struct {
			// S is the s argument value.
			S string
			// N is the n argument value.
			N int64
			// B is the b argument value.
			B bool
		}
		// GetFavorites holds details about calls to the GetFavorites method.
		GetFavorites []struct {
			// UserID is the userID argument value.
			UserID int64
		}
		// IncrementListenCount holds details about calls to the IncrementListenCount method.
		IncrementListenCount []struct {
			// N is the n argument value.
			N int64
		}
		// IsPlaylistOwner holds details about calls to the IsPlaylistOwner method.
		IsPlaylistOwner []struct {
			// N1 is the n1 argument value.
			N1 int64
			// N2 is the n2 argument value.
			N2 int64
		}
		// IsPlaylistPublic holds details about calls to the IsPlaylistPublic method.
		IsPlaylistPublic []struct {
			// N is the n argument value.
			N int64
		}
		// IsTrackInFavorites holds details about calls to the IsTrackInFavorites method.
		IsTrackInFavorites []struct {
			// UserID is the userID argument value.
			UserID int64
			// TrackID is the trackID argument value.
			TrackID int64
		}
		// PlaylistInfo holds details about calls to the PlaylistInfo method.
		PlaylistInfo []struct {
			// N is the n argument value.
			N int64
		}
		// PlaylistTracks holds details about calls to the PlaylistTracks method.
		PlaylistTracks []struct {
			// N1 is the n1 argument value.
			N1 int64
			// N2 is the n2 argument value.
			N2 int64
		}
		// RandomAlbums holds details about calls to the RandomAlbums method.
		RandomAlbums []struct {
			// N is the n argument value.
			N int64
		}
		// RandomArtists holds details about calls to the RandomArtists method.
		RandomArtists []struct {
			// N is the n argument value.
			N int64
		}
		// RandomTracks holds details about calls to the RandomTracks method.
		RandomTracks []struct {
			// N1 is the n1 argument value.
			N1 int64
			// N2 is the n2 argument value.
			N2 int64
			// B is the b argument value.
			B bool
		}
		// UserPlaylists holds details about calls to the UserPlaylists method.
		UserPlaylists []struct {
			// N is the n argument value.
			N int64
		}
	}
	lockAddTrackToFavorite       sync.RWMutex
	lockAlbumData                sync.RWMutex
	lockAlbumTracks              sync.RWMutex
	lockArtistAlbums             sync.RWMutex
	lockArtistInfo               sync.RWMutex
	lockArtistTracks             sync.RWMutex
	lockDeleteTrackFromFavorites sync.RWMutex
	lockDoesPlaylistExist        sync.RWMutex
	lockFindAlbums               sync.RWMutex
	lockFindArtists              sync.RWMutex
	lockFindTracksByFullWord     sync.RWMutex
	lockFindTracksByPartial      sync.RWMutex
	lockGetFavorites             sync.RWMutex
	lockIncrementListenCount     sync.RWMutex
	lockIsPlaylistOwner          sync.RWMutex
	lockIsPlaylistPublic         sync.RWMutex
	lockIsTrackInFavorites       sync.RWMutex
	lockPlaylistInfo             sync.RWMutex
	lockPlaylistTracks           sync.RWMutex
	lockRandomAlbums             sync.RWMutex
	lockRandomArtists            sync.RWMutex
	lockRandomTracks             sync.RWMutex
	lockUserPlaylists            sync.RWMutex
}

// AddTrackToFavorite calls AddTrackToFavoriteFunc.
func (mock *MockStorage) AddTrackToFavorite(userID int64, trackID int64) error {
	if mock.AddTrackToFavoriteFunc == nil {
		panic("MockStorage.AddTrackToFavoriteFunc: method is nil but Storage.AddTrackToFavorite was just called")
	}
	callInfo := struct {
		UserID  int64
		TrackID int64
	}{
		UserID:  userID,
		TrackID: trackID,
	}
	mock.lockAddTrackToFavorite.Lock()
	mock.calls.AddTrackToFavorite = append(mock.calls.AddTrackToFavorite, callInfo)
	mock.lockAddTrackToFavorite.Unlock()
	return mock.AddTrackToFavoriteFunc(userID, trackID)
}

// AddTrackToFavoriteCalls gets all the calls that were made to AddTrackToFavorite.
// Check the length with:
//     len(mockedStorage.AddTrackToFavoriteCalls())
func (mock *MockStorage) AddTrackToFavoriteCalls() []struct {
	UserID  int64
	TrackID int64
} {
	var calls []struct {
		UserID  int64
		TrackID int64
	}
	mock.lockAddTrackToFavorite.RLock()
	calls = mock.calls.AddTrackToFavorite
	mock.lockAddTrackToFavorite.RUnlock()
	return calls
}

// AlbumData calls AlbumDataFunc.
func (mock *MockStorage) AlbumData(n int64) (*proto.AlbumPageResponse, error) {
	if mock.AlbumDataFunc == nil {
		panic("MockStorage.AlbumDataFunc: method is nil but Storage.AlbumData was just called")
	}
	callInfo := struct {
		N int64
	}{
		N: n,
	}
	mock.lockAlbumData.Lock()
	mock.calls.AlbumData = append(mock.calls.AlbumData, callInfo)
	mock.lockAlbumData.Unlock()
	return mock.AlbumDataFunc(n)
}

// AlbumDataCalls gets all the calls that were made to AlbumData.
// Check the length with:
//     len(mockedStorage.AlbumDataCalls())
func (mock *MockStorage) AlbumDataCalls() []struct {
	N int64
} {
	var calls []struct {
		N int64
	}
	mock.lockAlbumData.RLock()
	calls = mock.calls.AlbumData
	mock.lockAlbumData.RUnlock()
	return calls
}

// AlbumTracks calls AlbumTracksFunc.
func (mock *MockStorage) AlbumTracks(n1 int64, n2 int64, b bool) ([]*proto.AlbumTrack, error) {
	if mock.AlbumTracksFunc == nil {
		panic("MockStorage.AlbumTracksFunc: method is nil but Storage.AlbumTracks was just called")
	}
	callInfo := struct {
		N1 int64
		N2 int64
		B  bool
	}{
		N1: n1,
		N2: n2,
		B:  b,
	}
	mock.lockAlbumTracks.Lock()
	mock.calls.AlbumTracks = append(mock.calls.AlbumTracks, callInfo)
	mock.lockAlbumTracks.Unlock()
	return mock.AlbumTracksFunc(n1, n2, b)
}

// AlbumTracksCalls gets all the calls that were made to AlbumTracks.
// Check the length with:
//     len(mockedStorage.AlbumTracksCalls())
func (mock *MockStorage) AlbumTracksCalls() []struct {
	N1 int64
	N2 int64
	B  bool
} {
	var calls []struct {
		N1 int64
		N2 int64
		B  bool
	}
	mock.lockAlbumTracks.RLock()
	calls = mock.calls.AlbumTracks
	mock.lockAlbumTracks.RUnlock()
	return calls
}

// ArtistAlbums calls ArtistAlbumsFunc.
func (mock *MockStorage) ArtistAlbums(n1 int64, n2 int64) ([]*proto.Album, error) {
	if mock.ArtistAlbumsFunc == nil {
		panic("MockStorage.ArtistAlbumsFunc: method is nil but Storage.ArtistAlbums was just called")
	}
	callInfo := struct {
		N1 int64
		N2 int64
	}{
		N1: n1,
		N2: n2,
	}
	mock.lockArtistAlbums.Lock()
	mock.calls.ArtistAlbums = append(mock.calls.ArtistAlbums, callInfo)
	mock.lockArtistAlbums.Unlock()
	return mock.ArtistAlbumsFunc(n1, n2)
}

// ArtistAlbumsCalls gets all the calls that were made to ArtistAlbums.
// Check the length with:
//     len(mockedStorage.ArtistAlbumsCalls())
func (mock *MockStorage) ArtistAlbumsCalls() []struct {
	N1 int64
	N2 int64
} {
	var calls []struct {
		N1 int64
		N2 int64
	}
	mock.lockArtistAlbums.RLock()
	calls = mock.calls.ArtistAlbums
	mock.lockArtistAlbums.RUnlock()
	return calls
}

// ArtistInfo calls ArtistInfoFunc.
func (mock *MockStorage) ArtistInfo(n int64) (*proto.Artist, error) {
	if mock.ArtistInfoFunc == nil {
		panic("MockStorage.ArtistInfoFunc: method is nil but Storage.ArtistInfo was just called")
	}
	callInfo := struct {
		N int64
	}{
		N: n,
	}
	mock.lockArtistInfo.Lock()
	mock.calls.ArtistInfo = append(mock.calls.ArtistInfo, callInfo)
	mock.lockArtistInfo.Unlock()
	return mock.ArtistInfoFunc(n)
}

// ArtistInfoCalls gets all the calls that were made to ArtistInfo.
// Check the length with:
//     len(mockedStorage.ArtistInfoCalls())
func (mock *MockStorage) ArtistInfoCalls() []struct {
	N int64
} {
	var calls []struct {
		N int64
	}
	mock.lockArtistInfo.RLock()
	calls = mock.calls.ArtistInfo
	mock.lockArtistInfo.RUnlock()
	return calls
}

// ArtistTracks calls ArtistTracksFunc.
func (mock *MockStorage) ArtistTracks(n1 int64, n2 int64, b bool, n3 int64) ([]*proto.Track, error) {
	if mock.ArtistTracksFunc == nil {
		panic("MockStorage.ArtistTracksFunc: method is nil but Storage.ArtistTracks was just called")
	}
	callInfo := struct {
		N1 int64
		N2 int64
		B  bool
		N3 int64
	}{
		N1: n1,
		N2: n2,
		B:  b,
		N3: n3,
	}
	mock.lockArtistTracks.Lock()
	mock.calls.ArtistTracks = append(mock.calls.ArtistTracks, callInfo)
	mock.lockArtistTracks.Unlock()
	return mock.ArtistTracksFunc(n1, n2, b, n3)
}

// ArtistTracksCalls gets all the calls that were made to ArtistTracks.
// Check the length with:
//     len(mockedStorage.ArtistTracksCalls())
func (mock *MockStorage) ArtistTracksCalls() []struct {
	N1 int64
	N2 int64
	B  bool
	N3 int64
} {
	var calls []struct {
		N1 int64
		N2 int64
		B  bool
		N3 int64
	}
	mock.lockArtistTracks.RLock()
	calls = mock.calls.ArtistTracks
	mock.lockArtistTracks.RUnlock()
	return calls
}

// DeleteTrackFromFavorites calls DeleteTrackFromFavoritesFunc.
func (mock *MockStorage) DeleteTrackFromFavorites(userID int64, trackID int64) error {
	if mock.DeleteTrackFromFavoritesFunc == nil {
		panic("MockStorage.DeleteTrackFromFavoritesFunc: method is nil but Storage.DeleteTrackFromFavorites was just called")
	}
	callInfo := struct {
		UserID  int64
		TrackID int64
	}{
		UserID:  userID,
		TrackID: trackID,
	}
	mock.lockDeleteTrackFromFavorites.Lock()
	mock.calls.DeleteTrackFromFavorites = append(mock.calls.DeleteTrackFromFavorites, callInfo)
	mock.lockDeleteTrackFromFavorites.Unlock()
	return mock.DeleteTrackFromFavoritesFunc(userID, trackID)
}

// DeleteTrackFromFavoritesCalls gets all the calls that were made to DeleteTrackFromFavorites.
// Check the length with:
//     len(mockedStorage.DeleteTrackFromFavoritesCalls())
func (mock *MockStorage) DeleteTrackFromFavoritesCalls() []struct {
	UserID  int64
	TrackID int64
} {
	var calls []struct {
		UserID  int64
		TrackID int64
	}
	mock.lockDeleteTrackFromFavorites.RLock()
	calls = mock.calls.DeleteTrackFromFavorites
	mock.lockDeleteTrackFromFavorites.RUnlock()
	return calls
}

// DoesPlaylistExist calls DoesPlaylistExistFunc.
func (mock *MockStorage) DoesPlaylistExist(n int64) (bool, error) {
	if mock.DoesPlaylistExistFunc == nil {
		panic("MockStorage.DoesPlaylistExistFunc: method is nil but Storage.DoesPlaylistExist was just called")
	}
	callInfo := struct {
		N int64
	}{
		N: n,
	}
	mock.lockDoesPlaylistExist.Lock()
	mock.calls.DoesPlaylistExist = append(mock.calls.DoesPlaylistExist, callInfo)
	mock.lockDoesPlaylistExist.Unlock()
	return mock.DoesPlaylistExistFunc(n)
}

// DoesPlaylistExistCalls gets all the calls that were made to DoesPlaylistExist.
// Check the length with:
//     len(mockedStorage.DoesPlaylistExistCalls())
func (mock *MockStorage) DoesPlaylistExistCalls() []struct {
	N int64
} {
	var calls []struct {
		N int64
	}
	mock.lockDoesPlaylistExist.RLock()
	calls = mock.calls.DoesPlaylistExist
	mock.lockDoesPlaylistExist.RUnlock()
	return calls
}

// FindAlbums calls FindAlbumsFunc.
func (mock *MockStorage) FindAlbums(s string) ([]*proto.Album, error) {
	if mock.FindAlbumsFunc == nil {
		panic("MockStorage.FindAlbumsFunc: method is nil but Storage.FindAlbums was just called")
	}
	callInfo := struct {
		S string
	}{
		S: s,
	}
	mock.lockFindAlbums.Lock()
	mock.calls.FindAlbums = append(mock.calls.FindAlbums, callInfo)
	mock.lockFindAlbums.Unlock()
	return mock.FindAlbumsFunc(s)
}

// FindAlbumsCalls gets all the calls that were made to FindAlbums.
// Check the length with:
//     len(mockedStorage.FindAlbumsCalls())
func (mock *MockStorage) FindAlbumsCalls() []struct {
	S string
} {
	var calls []struct {
		S string
	}
	mock.lockFindAlbums.RLock()
	calls = mock.calls.FindAlbums
	mock.lockFindAlbums.RUnlock()
	return calls
}

// FindArtists calls FindArtistsFunc.
func (mock *MockStorage) FindArtists(s string) ([]*proto.Artist, error) {
	if mock.FindArtistsFunc == nil {
		panic("MockStorage.FindArtistsFunc: method is nil but Storage.FindArtists was just called")
	}
	callInfo := struct {
		S string
	}{
		S: s,
	}
	mock.lockFindArtists.Lock()
	mock.calls.FindArtists = append(mock.calls.FindArtists, callInfo)
	mock.lockFindArtists.Unlock()
	return mock.FindArtistsFunc(s)
}

// FindArtistsCalls gets all the calls that were made to FindArtists.
// Check the length with:
//     len(mockedStorage.FindArtistsCalls())
func (mock *MockStorage) FindArtistsCalls() []struct {
	S string
} {
	var calls []struct {
		S string
	}
	mock.lockFindArtists.RLock()
	calls = mock.calls.FindArtists
	mock.lockFindArtists.RUnlock()
	return calls
}

// FindTracksByFullWord calls FindTracksByFullWordFunc.
func (mock *MockStorage) FindTracksByFullWord(s string, n int64, b bool) ([]*proto.Track, error) {
	if mock.FindTracksByFullWordFunc == nil {
		panic("MockStorage.FindTracksByFullWordFunc: method is nil but Storage.FindTracksByFullWord was just called")
	}
	callInfo := struct {
		S string
		N int64
		B bool
	}{
		S: s,
		N: n,
		B: b,
	}
	mock.lockFindTracksByFullWord.Lock()
	mock.calls.FindTracksByFullWord = append(mock.calls.FindTracksByFullWord, callInfo)
	mock.lockFindTracksByFullWord.Unlock()
	return mock.FindTracksByFullWordFunc(s, n, b)
}

// FindTracksByFullWordCalls gets all the calls that were made to FindTracksByFullWord.
// Check the length with:
//     len(mockedStorage.FindTracksByFullWordCalls())
func (mock *MockStorage) FindTracksByFullWordCalls() []struct {
	S string
	N int64
	B bool
} {
	var calls []struct {
		S string
		N int64
		B bool
	}
	mock.lockFindTracksByFullWord.RLock()
	calls = mock.calls.FindTracksByFullWord
	mock.lockFindTracksByFullWord.RUnlock()
	return calls
}

// FindTracksByPartial calls FindTracksByPartialFunc.
func (mock *MockStorage) FindTracksByPartial(s string, n int64, b bool) ([]*proto.Track, error) {
	if mock.FindTracksByPartialFunc == nil {
		panic("MockStorage.FindTracksByPartialFunc: method is nil but Storage.FindTracksByPartial was just called")
	}
	callInfo := struct {
		S string
		N int64
		B bool
	}{
		S: s,
		N: n,
		B: b,
	}
	mock.lockFindTracksByPartial.Lock()
	mock.calls.FindTracksByPartial = append(mock.calls.FindTracksByPartial, callInfo)
	mock.lockFindTracksByPartial.Unlock()
	return mock.FindTracksByPartialFunc(s, n, b)
}

// FindTracksByPartialCalls gets all the calls that were made to FindTracksByPartial.
// Check the length with:
//     len(mockedStorage.FindTracksByPartialCalls())
func (mock *MockStorage) FindTracksByPartialCalls() []struct {
	S string
	N int64
	B bool
} {
	var calls []struct {
		S string
		N int64
		B bool
	}
	mock.lockFindTracksByPartial.RLock()
	calls = mock.calls.FindTracksByPartial
	mock.lockFindTracksByPartial.RUnlock()
	return calls
}

// GetFavorites calls GetFavoritesFunc.
func (mock *MockStorage) GetFavorites(userID int64) ([]*proto.Track, error) {
	if mock.GetFavoritesFunc == nil {
		panic("MockStorage.GetFavoritesFunc: method is nil but Storage.GetFavorites was just called")
	}
	callInfo := struct {
		UserID int64
	}{
		UserID: userID,
	}
	mock.lockGetFavorites.Lock()
	mock.calls.GetFavorites = append(mock.calls.GetFavorites, callInfo)
	mock.lockGetFavorites.Unlock()
	return mock.GetFavoritesFunc(userID)
}

// GetFavoritesCalls gets all the calls that were made to GetFavorites.
// Check the length with:
//     len(mockedStorage.GetFavoritesCalls())
func (mock *MockStorage) GetFavoritesCalls() []struct {
	UserID int64
} {
	var calls []struct {
		UserID int64
	}
	mock.lockGetFavorites.RLock()
	calls = mock.calls.GetFavorites
	mock.lockGetFavorites.RUnlock()
	return calls
}

// IncrementListenCount calls IncrementListenCountFunc.
func (mock *MockStorage) IncrementListenCount(n int64) error {
	if mock.IncrementListenCountFunc == nil {
		panic("MockStorage.IncrementListenCountFunc: method is nil but Storage.IncrementListenCount was just called")
	}
	callInfo := struct {
		N int64
	}{
		N: n,
	}
	mock.lockIncrementListenCount.Lock()
	mock.calls.IncrementListenCount = append(mock.calls.IncrementListenCount, callInfo)
	mock.lockIncrementListenCount.Unlock()
	return mock.IncrementListenCountFunc(n)
}

// IncrementListenCountCalls gets all the calls that were made to IncrementListenCount.
// Check the length with:
//     len(mockedStorage.IncrementListenCountCalls())
func (mock *MockStorage) IncrementListenCountCalls() []struct {
	N int64
} {
	var calls []struct {
		N int64
	}
	mock.lockIncrementListenCount.RLock()
	calls = mock.calls.IncrementListenCount
	mock.lockIncrementListenCount.RUnlock()
	return calls
}

// IsPlaylistOwner calls IsPlaylistOwnerFunc.
func (mock *MockStorage) IsPlaylistOwner(n1 int64, n2 int64) (bool, error) {
	if mock.IsPlaylistOwnerFunc == nil {
		panic("MockStorage.IsPlaylistOwnerFunc: method is nil but Storage.IsPlaylistOwner was just called")
	}
	callInfo := struct {
		N1 int64
		N2 int64
	}{
		N1: n1,
		N2: n2,
	}
	mock.lockIsPlaylistOwner.Lock()
	mock.calls.IsPlaylistOwner = append(mock.calls.IsPlaylistOwner, callInfo)
	mock.lockIsPlaylistOwner.Unlock()
	return mock.IsPlaylistOwnerFunc(n1, n2)
}

// IsPlaylistOwnerCalls gets all the calls that were made to IsPlaylistOwner.
// Check the length with:
//     len(mockedStorage.IsPlaylistOwnerCalls())
func (mock *MockStorage) IsPlaylistOwnerCalls() []struct {
	N1 int64
	N2 int64
} {
	var calls []struct {
		N1 int64
		N2 int64
	}
	mock.lockIsPlaylistOwner.RLock()
	calls = mock.calls.IsPlaylistOwner
	mock.lockIsPlaylistOwner.RUnlock()
	return calls
}

// IsPlaylistPublic calls IsPlaylistPublicFunc.
func (mock *MockStorage) IsPlaylistPublic(n int64) (bool, error) {
	if mock.IsPlaylistPublicFunc == nil {
		panic("MockStorage.IsPlaylistPublicFunc: method is nil but Storage.IsPlaylistPublic was just called")
	}
	callInfo := struct {
		N int64
	}{
		N: n,
	}
	mock.lockIsPlaylistPublic.Lock()
	mock.calls.IsPlaylistPublic = append(mock.calls.IsPlaylistPublic, callInfo)
	mock.lockIsPlaylistPublic.Unlock()
	return mock.IsPlaylistPublicFunc(n)
}

// IsPlaylistPublicCalls gets all the calls that were made to IsPlaylistPublic.
// Check the length with:
//     len(mockedStorage.IsPlaylistPublicCalls())
func (mock *MockStorage) IsPlaylistPublicCalls() []struct {
	N int64
} {
	var calls []struct {
		N int64
	}
	mock.lockIsPlaylistPublic.RLock()
	calls = mock.calls.IsPlaylistPublic
	mock.lockIsPlaylistPublic.RUnlock()
	return calls
}

// IsTrackInFavorites calls IsTrackInFavoritesFunc.
func (mock *MockStorage) IsTrackInFavorites(userID int64, trackID int64) (bool, error) {
	if mock.IsTrackInFavoritesFunc == nil {
		panic("MockStorage.IsTrackInFavoritesFunc: method is nil but Storage.IsTrackInFavorites was just called")
	}
	callInfo := struct {
		UserID  int64
		TrackID int64
	}{
		UserID:  userID,
		TrackID: trackID,
	}
	mock.lockIsTrackInFavorites.Lock()
	mock.calls.IsTrackInFavorites = append(mock.calls.IsTrackInFavorites, callInfo)
	mock.lockIsTrackInFavorites.Unlock()
	return mock.IsTrackInFavoritesFunc(userID, trackID)
}

// IsTrackInFavoritesCalls gets all the calls that were made to IsTrackInFavorites.
// Check the length with:
//     len(mockedStorage.IsTrackInFavoritesCalls())
func (mock *MockStorage) IsTrackInFavoritesCalls() []struct {
	UserID  int64
	TrackID int64
} {
	var calls []struct {
		UserID  int64
		TrackID int64
	}
	mock.lockIsTrackInFavorites.RLock()
	calls = mock.calls.IsTrackInFavorites
	mock.lockIsTrackInFavorites.RUnlock()
	return calls
}

// PlaylistInfo calls PlaylistInfoFunc.
func (mock *MockStorage) PlaylistInfo(n int64) (*proto.PlaylistData, error) {
	if mock.PlaylistInfoFunc == nil {
		panic("MockStorage.PlaylistInfoFunc: method is nil but Storage.PlaylistInfo was just called")
	}
	callInfo := struct {
		N int64
	}{
		N: n,
	}
	mock.lockPlaylistInfo.Lock()
	mock.calls.PlaylistInfo = append(mock.calls.PlaylistInfo, callInfo)
	mock.lockPlaylistInfo.Unlock()
	return mock.PlaylistInfoFunc(n)
}

// PlaylistInfoCalls gets all the calls that were made to PlaylistInfo.
// Check the length with:
//     len(mockedStorage.PlaylistInfoCalls())
func (mock *MockStorage) PlaylistInfoCalls() []struct {
	N int64
} {
	var calls []struct {
		N int64
	}
	mock.lockPlaylistInfo.RLock()
	calls = mock.calls.PlaylistInfo
	mock.lockPlaylistInfo.RUnlock()
	return calls
}

// PlaylistTracks calls PlaylistTracksFunc.
func (mock *MockStorage) PlaylistTracks(n1 int64, n2 int64) ([]*proto.Track, error) {
	if mock.PlaylistTracksFunc == nil {
		panic("MockStorage.PlaylistTracksFunc: method is nil but Storage.PlaylistTracks was just called")
	}
	callInfo := struct {
		N1 int64
		N2 int64
	}{
		N1: n1,
		N2: n2,
	}
	mock.lockPlaylistTracks.Lock()
	mock.calls.PlaylistTracks = append(mock.calls.PlaylistTracks, callInfo)
	mock.lockPlaylistTracks.Unlock()
	return mock.PlaylistTracksFunc(n1, n2)
}

// PlaylistTracksCalls gets all the calls that were made to PlaylistTracks.
// Check the length with:
//     len(mockedStorage.PlaylistTracksCalls())
func (mock *MockStorage) PlaylistTracksCalls() []struct {
	N1 int64
	N2 int64
} {
	var calls []struct {
		N1 int64
		N2 int64
	}
	mock.lockPlaylistTracks.RLock()
	calls = mock.calls.PlaylistTracks
	mock.lockPlaylistTracks.RUnlock()
	return calls
}

// RandomAlbums calls RandomAlbumsFunc.
func (mock *MockStorage) RandomAlbums(n int64) (*proto.Albums, error) {
	if mock.RandomAlbumsFunc == nil {
		panic("MockStorage.RandomAlbumsFunc: method is nil but Storage.RandomAlbums was just called")
	}
	callInfo := struct {
		N int64
	}{
		N: n,
	}
	mock.lockRandomAlbums.Lock()
	mock.calls.RandomAlbums = append(mock.calls.RandomAlbums, callInfo)
	mock.lockRandomAlbums.Unlock()
	return mock.RandomAlbumsFunc(n)
}

// RandomAlbumsCalls gets all the calls that were made to RandomAlbums.
// Check the length with:
//     len(mockedStorage.RandomAlbumsCalls())
func (mock *MockStorage) RandomAlbumsCalls() []struct {
	N int64
} {
	var calls []struct {
		N int64
	}
	mock.lockRandomAlbums.RLock()
	calls = mock.calls.RandomAlbums
	mock.lockRandomAlbums.RUnlock()
	return calls
}

// RandomArtists calls RandomArtistsFunc.
func (mock *MockStorage) RandomArtists(n int64) (*proto.Artists, error) {
	if mock.RandomArtistsFunc == nil {
		panic("MockStorage.RandomArtistsFunc: method is nil but Storage.RandomArtists was just called")
	}
	callInfo := struct {
		N int64
	}{
		N: n,
	}
	mock.lockRandomArtists.Lock()
	mock.calls.RandomArtists = append(mock.calls.RandomArtists, callInfo)
	mock.lockRandomArtists.Unlock()
	return mock.RandomArtistsFunc(n)
}

// RandomArtistsCalls gets all the calls that were made to RandomArtists.
// Check the length with:
//     len(mockedStorage.RandomArtistsCalls())
func (mock *MockStorage) RandomArtistsCalls() []struct {
	N int64
} {
	var calls []struct {
		N int64
	}
	mock.lockRandomArtists.RLock()
	calls = mock.calls.RandomArtists
	mock.lockRandomArtists.RUnlock()
	return calls
}

// RandomTracks calls RandomTracksFunc.
func (mock *MockStorage) RandomTracks(n1 int64, n2 int64, b bool) (*proto.Tracks, error) {
	if mock.RandomTracksFunc == nil {
		panic("MockStorage.RandomTracksFunc: method is nil but Storage.RandomTracks was just called")
	}
	callInfo := struct {
		N1 int64
		N2 int64
		B  bool
	}{
		N1: n1,
		N2: n2,
		B:  b,
	}
	mock.lockRandomTracks.Lock()
	mock.calls.RandomTracks = append(mock.calls.RandomTracks, callInfo)
	mock.lockRandomTracks.Unlock()
	return mock.RandomTracksFunc(n1, n2, b)
}

// RandomTracksCalls gets all the calls that were made to RandomTracks.
// Check the length with:
//     len(mockedStorage.RandomTracksCalls())
func (mock *MockStorage) RandomTracksCalls() []struct {
	N1 int64
	N2 int64
	B  bool
} {
	var calls []struct {
		N1 int64
		N2 int64
		B  bool
	}
	mock.lockRandomTracks.RLock()
	calls = mock.calls.RandomTracks
	mock.lockRandomTracks.RUnlock()
	return calls
}

// UserPlaylists calls UserPlaylistsFunc.
func (mock *MockStorage) UserPlaylists(n int64) ([]*proto.PlaylistData, error) {
	if mock.UserPlaylistsFunc == nil {
		panic("MockStorage.UserPlaylistsFunc: method is nil but Storage.UserPlaylists was just called")
	}
	callInfo := struct {
		N int64
	}{
		N: n,
	}
	mock.lockUserPlaylists.Lock()
	mock.calls.UserPlaylists = append(mock.calls.UserPlaylists, callInfo)
	mock.lockUserPlaylists.Unlock()
	return mock.UserPlaylistsFunc(n)
}

// UserPlaylistsCalls gets all the calls that were made to UserPlaylists.
// Check the length with:
//     len(mockedStorage.UserPlaylistsCalls())
func (mock *MockStorage) UserPlaylistsCalls() []struct {
	N int64
} {
	var calls []struct {
		N int64
	}
	mock.lockUserPlaylists.RLock()
	calls = mock.calls.UserPlaylists
	mock.lockUserPlaylists.RUnlock()
	return calls
}
